defmodule Parser do
  @moduledoc """
  The `Parser` module is responsible for parsing a list of tokens generated by a lexer.
  It supports parsing expressions involving variables, numbers, arithmetic operators,
  comparison operators, and parentheses.

  The parser works recursively to generate a tree-like structure representing the input
  expression. The top-level expression is parsed by calling the `parse/1` function, which
  returns an abstract syntax tree (AST) or an error if the input is invalid.
  """

  @doc """
  The main function to parse a list of tokens.
  It attempts to parse binary operations and then recursively parses any remaining tokens.

  ## Parameters
    - `tokens`: A list of tokens.

  ## Returns
    - `{:ok, expr}`: A tuple containing the successfully parsed expression.
    - `{:err, message}`: A tuple containing an error message if parsing fails.
  """
  def parse([]) do
    {:ok, {}}
  end

  def parse(tokens) do
    case parse_bop(tokens) do
      {:err, _} = error -> error
      {expr, rest} ->
        case parse(rest) do
          {:ok, {}} -> {:ok, expr}
          {:ok, next_expr} -> {:ok, expr, next_expr}
          {:err, _} = error -> error
        end
    end
  end

  # Private function to parse individual factors (numbers, variables, and expressions within parentheses).
  defp parse_factor([]) do
    {:err, "Unexpected end of input"}
  end

  defp parse_factor([token | rest]) do
    case token do
      {:num, _} -> {token, rest}
      {:var, _} -> {token, rest}
      {:lparen} ->
        case parse_op(rest) do
          {:err, _} = error -> error
          {expr, rest1} ->
            case rest1 do
              [{:rparen} | rest2] -> {expr, rest2}
              _ -> {:err, "Expected a right parenthesis"}
            end
        end
      _ -> {:err, "Unexpected token: #{inspect(token)}"}
    end
  end

  # Private function to parse terms. A term could be a factor followed by multiplication or division.
  # Add validation to ensure the next token isn't a number or variable (without an operator).
  defp parse_term([]) do
    {:err, "Unexpected end of input"}
  end

  defp parse_term(tokens) do
    case parse_factor(tokens) do
      {:err, _} = error -> error
      {l_expr, rest} ->
        case rest do
          [{:op, :mul} | rest1] ->
            case parse_term(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :mul, r_expr}, rest2}
            end
          [{:op, :div} | rest1] ->
            case parse_term(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :div, r_expr}, rest2}
            end
          [{:num, _} | _] ->
            {:err, "Unexpected number without an operator between expressions"}
          [{:var, _} | _] ->
            {:err, "Unexpected variable without an operator between expressions"}
          _ -> {l_expr, rest}
        end
    end
  end

  # Private function to parse binary operations involving comparison operators.
  defp parse_bop([]) do
    {:err, "Unexpected end of input"}
  end

  defp parse_bop(tokens) do
    case parse_op(tokens) do
      {:err, _} = error -> error
      {l_expr, rest} ->
        case rest do
          [{:op, :ge} | rest1] ->
            case parse_bop(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :ge, r_expr}, rest2}
            end
          [{:op, :gt} | rest1] ->
            case parse_bop(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :gt, r_expr}, rest2}
            end
          [{:op, :le} | rest1] ->
            case parse_bop(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :le, r_expr}, rest2}
            end
          [{:op, :lt} | rest1] ->
            case parse_bop(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :lt, r_expr}, rest2}
            end
          [{:op, :eq} | rest1] ->
            case parse_bop(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :eq, r_expr}, rest2}
            end
          [{:op, :neq} | rest1] ->
            case parse_bop(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :neq, r_expr}, rest2}
            end
          _ -> {l_expr, rest}
        end
    end
  end

  # Private function to parse operations involving addition and subtraction.
  defp parse_op([]) do
    {:err, "Unexpected end of input"}
  end

  defp parse_op(tokens) do
    case parse_term(tokens) do
      {:err, _} = error -> error
      {l_expr, rest} ->
        case rest do
          [{:op, :add} | rest1] ->
            case parse_op(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :add, r_expr}, rest2}
            end
          [{:op, :sub} | rest1] ->
            case parse_op(rest1) do
              {:err, _} = error -> error
              {r_expr, rest2} -> {{l_expr, :sub, r_expr}, rest2}
            end
          _ -> {l_expr, rest}
        end
    end
  end
end
